# -*- coding: utf-8 -*-
"""FeatExtract_Segment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Fw4gvJ_elGPbG4sZnxoYqUlGPoNf_Xbt
"""

from google.colab import drive
drive.mount('/content/gdrive')

import numpy as np
import cv2 
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
import scipy
import os
os.chdir('/content/gdrive/My Drive/MP2/')

#Read Images
img = cv2.imread('benign_4x/_11001.tif')
img_gt = cv2.imread('benign_4x/_11001_gt.png')
img_gt = np.array(img_gt)

#Show original and ground truth image
fig, (a1,a2) = plt.subplots(1,2, figsize=(25,25))
a1.imshow(img)
a2.imshow(img_gt)
fig.show

#Extract Gabor Features

ksize = 9  # Size of Gabor kernel
theta = 0.0 
gamma = 1

#converting to grayscale
img_grey= cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
kernels = []
features = []

for sigma in np.arange(1,2,0.5):
  for lamda in np.arange(3,5,0.25):
    for gamma in np.arange(0.5,1.25,0.25):
      k = cv2.getGaborKernel((ksize, ksize), sigma, theta, lamda, gamma, 0, ktype=cv2.CV_32F)   
      kernels.append(k) 
      fimg = cv2.filter2D(img_grey, cv2.CV_8UC1, k)
      #fimg = cv2.GaussianBlur(fimg, (15,15), 5, 5)
      fimg = cv2.medianBlur(fimg, 11)
      fimg = fimg.reshape((fimg.shape[0]*fimg.shape[1],))
      features.append(fimg)

features = np.array(features)
features = features.T
kernels = np.array(kernels)

#K Means Clustering
kmeans = KMeans(n_clusters=3)
kmeans.fit(features)
y = kmeans.predict(features)
img_seg = y.reshape((img.shape[0], img.shape[1]))
img_seg_copy = np.copy(img_seg)

#Plotting Segmented Image
fig, (a1,a2,a3) = plt.subplots(1,3, figsize=(25,25))
a1.imshow(img)
a2.imshow(img_gt)
a3.imshow(img_seg)
fig.show

#Find Contours
contours, heirarchy = cv2.findContours(np.uint8(img_seg), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)

#Finding top n contours with maximum areas
n = 2
areas = []

for cnt in contours:
  area = cv2.contourArea(cnt)
  areas.append(area)

areas = np.array(areas)
ind = np.argsort(-1*areas)
max1 = contours[ind[0]]
max2 = contours[ind[1]]

z = np.zeros(img_seg.shape)
cv2.drawContours(z,contours[ind[0]], -1,(255,255,255), 3 )
cv2.drawContours(z,contours[ind[1]], -1,(255,255,255), 3 )

plt.imshow(z, cmap = 'gray')
plt.show()

masked_image = scipy.ndimage.morphology.binary_fill_holes(z)
plt.imshow(masked_image, cmap = 'gray')
plt.show()

#Labelling the image

(labels, counts) = np.unique(img_seg[masked_image], return_counts= True)
cellClusterLabel = labels[np.argmax(counts)]
print(cellClusterLabel)
masked_img_inv = masked_image == False
isolatedMask = ((img_seg *masked_img_inv) == cellClusterLabel).astype(int)
isolatedMask[masked_image] = 2

img_gt_gray = cv2.cvtColor(img_gt, cv2.COLOR_BGR2GRAY)

#Plotting correctly labelled Segmented Image
fig, (a1,a2,a3) = plt.subplots(1,3, figsize=(25,25))
a1.imshow(img)
a2.imshow(img_gt)
a3.imshow(isolatedMask, cmap = 'gray')
fig.show

#Calculate dice score 

dice = []
for k in (0,1,2):
  dice.append(np.sum(isolatedMask[img_gt==k])*2.0 / (np.sum(isolatedMask) + np.sum(img_gt)))

print(dice)

